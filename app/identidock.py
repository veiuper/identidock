# Инициализация Flask и настройка объекта приложения.
# Импорт из пакета Flask модуля Response, используемого для передачи изображений.
from flask import Flask, Response, request
# Импорт библиотеки requests (http://docs.python-requests.org/en/latest/),
# используемой для организации диалога с сервисом dnmonster.
import requests
# Импорт библиотеки, которая будет использоваться для хэширования данных, вводимых пользователем.
# Так как это стандартная библиотека, для ее установки вносить изменения в Dockerfile не нужно.
import hashlib
# Импорт модуля Redis.
import redis
app = Flask(__name__)
# Определение значения переменной salt, используемой в хэш-функции.
# При изменении этого значения разные сайты могут генерировать
# различные идентификационные пиктограммы для одних и тех же входных данных.
salt = "UNIQUE_SALT"
# Настройка кэша Redis. Мы будем использовать соединения Docker,
# чтобы обеспечить доступность имени хоста redis.
cache = redis.StrictRedis( host='redis', port=6379, db=0 )
default_name = 'Joe Bloggs'
# Создание маршрута , связанного с целевым URL.
# При любом обращении к этому URL будет вызываться функция hello_world.
# По умолчанию сервер Flask определяет пути только для ответов на HTTP-запросы GET.
# Форма в исходном коде отправляет HTTP-запрос POST,
# поэтому необходимо добавить именованный аргумент methods к списку путей
# и в явной форме определить, что в данном случае будут обрабатываться оба запроса POST и GET.
@app.route('/', methods=['GET', 'POST'])

def mainpage():
    name = default_name
    # Если значение request.method равно значению "POST",
    # то этот запрос является результатом щелчка по кнопке подтверждения отправки данных (submit).
    # В этом случае необходимо обновить переменную name,
    # присвоив ей текстовое значение, введенное пользователем.
    if request.method == 'POST':
        name = request.form['name']
    salted_name = salt + name
    # Выполнение операции хэширования введенных данных с использованием алгоритма SHA256.
    name_hash = hashlib.sha256( salted_name.encode() ).hexdigest()
    header = '<html><head><title>Identidock</title></head><body>'
    body = '''<form method="POST">
    Hello <input type="text" name="name" value="{0}">
    <input type="submit" value="submit">
    </form>
    <p>You look like a:
    <img src="/monster/{1}"/>
    '''.format( name, name_hash )
    # Изменение URL изображения с учетом полученного выше хэшированного значения.
    # При попытке загрузки файла изображения браузер будет вызывать функцию get_identicon,
    # учитывая заданный путь и это хэшированное значение.
    footer = '</body></html>'
    return header + body + footer

@app.route('/monster/<name>')

def get_identicon( name ):
    # Проверка наличия текущего значения переменной name в кэше.
    image = cache.get( name )
    # При промахе кэша (то есть при отсутствии текущего значения в кэше) Redis возвращает значение None.
    # В этом случае изображение генерируется как обычно, а кроме того...
    if image is None:
        # Выводится некоторая отладочная информация об отсутствии кэшированного изображения и...
        print( "Cache miss (промах кэша)", flush=True )
    # Создание HTTP-запроса GET, отправляемого сервису dnmonster.
    # Запрашивается имя идентификационного изображения как значение переменной name,
    # при этом размер изображения должен быть равен 80 пикселам.
    r = requests.get( 'http://dnmonster:8080/monster/' + name + '?size=80' )
    image = r.content
    # Сгенерированный образ добавляется в кэш и связывается с заданным именем.
    cache.set( name, image )
    # Оператор return немного усложняется из-за использования функции Response,
    # сообщающей серверу Flask о том, что возвращается изображение в формате PNG,
    # а не HTML-код и не текст.
    return Response( image, mimetype='image/png' )
# Инициализация веб-сервера в программной среде Python.
# Использование адреса 0.0.0.0 (вместо localhost или 127.0.0.1)
# в качестве аргумента host позволяет выполнить привязку всех сетевых интерфейсов.
# Это необходимо для обеспечения доступа к контейнеру с хоста и из других контейнеров.
# Оператор if в предыдущей строке обеспечивает выполнение текущей строки только в том случае,
# когда файл вызывается как независимая программа,
# а не запускается как составная часть более крупного приложения.
if __name__ == '__main__':
    app.run( debug=True, host='0.0.0.0' )
